import logging
import tkinter as tk
from tkinter import Entry, Label, messagebox
import random
from socks import send_data_through_socks_proxy
from config import env
from log import logs
import time

logger = logs("client.log")


def on_button_click():
    start = time.time()

    num = get_chains_number()
    if num is not None:
        list = generate_chains(total=num)
        generate_file(chains=list)
        response = send_data_through_socks_proxy(list, num, logger)
        write_response(response=response)

    end = time.time()
    duration = end - start
    logger.info(f'Process completed in {duration} seconds.')


def close_window(event=None):
    root.destroy()


root = tk.Tk()
root.title("Avangenio Exercise")
root.bind('<Escape>', close_window)
root.resizable(False, False)

Label(text="Enter the chains number to generate: \n By default is 1 000 000").pack(pady=5)
chains_number = Entry(root, width=30)
chains_number.insert(0, "1000000")
chains_number.pack(pady=5)

button = tk.Button(root, text="Generate chains", command=on_button_click)
button.pack(pady=10)

button2 = tk.Button(root, text="Close", command=close_window)
button2.pack(pady=10)


def get_chains_number():
    """
    Gets the value of the number of strings to generate from the input at run time
    """

    try:
        num = int(chains_number.get())
        if num > 0:
            return num
    except ValueError:
        logger.error("Please enter a valid integer. Must be greater than zero.")
        messagebox.showwarning("Warning", "Please enter a valid integer. Must be greater than zero.")
        return None


def pick_random_non_consecutive(lower_bound, upper_bound, num_spaces):
    """
    Select num_spaces number of numbers within the range of lower_bound and upper_bound, excluding this upper_bound
    """

    # Generate a list of potential candidates
    candidates = list(range(lower_bound, upper_bound))
    selected_numbers = []

    for _ in range(num_spaces):
        # Shuffle the list to randomize the order
        random.shuffle(candidates)

        # Select the first number
        selected_number = candidates.pop(0)

        # Remove already selected numbers to avoid repetition
        candidates = [n for n in candidates if abs(n - selected_number) > 1]

        selected_numbers.append(selected_number)
    return selected_numbers


def generate_chains(total=1000000):
    """
        Randomly generates a total number of strings given by parameter with characters a-z A-Z 0-9 and spaces,
        with a length of 50 to 100 characters, and 3 to 5 non-consecutive spaces. The number of strings to be
        generated by default is one million
    """

    allowed_chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    num_spaces = random.randint(a=env.get("MIN_SPACES"), b=env.get("MAX_SPACES"))
    list = []

    for i in range(0, total):
        num = random.randint(a=env.get("MIN_CHAIN") - num_spaces, b=env.get("MAX_CHAIN") - num_spaces)
        chain = ''.join(random.choice(allowed_chars) for _ in range(num))
        selected_numbers = pick_random_non_consecutive(2, len(chain) - 1, num_spaces)

        for _ in range(num_spaces):
            position = selected_numbers.pop(0)
            chain = chain[:position - 1] + ' ' + chain[position:]
        list.append(chain)
        logger.info(f'Chain generated >>> "{chain}"')

    return list


def generate_file(name='chains.txt', chains=None):
    """
    Generates a txt file with the strings given per parameter. The default file name is chains.txt
    """

    if chains is None:
        logger.info(f"There is no chains to write into file")
        return
    if env.get("CHAINS_FILE_NAME") is not None:
        name = env.get("CHAINS_FILE_NAME")
    with open(file=name, mode="w") as file:
        for chain in chains:
            file.write(chain + "\n")
    file.close()
    logger.info(f"File {name} has been generated with the strings.")


def write_response(name='response.txt', response=None, separating_element=">>>"):
    """
    Generates a txt file with the response given per parameter. The default file name is response.txt
    The response format of the file lines is a tuple (float, str). The float value is the weight of the string,
    and the str its respective string
    """

    if response is None:
        response = []
    if env.get("RESPONSE_FILE_NAME") is not None:
        name = env.get("RESPONSE_FILE_NAME")
    if env.get("SEPARATING_ELEMENT") is not None:
        separating_element = env.get("SEPARATING_ELEMENT")
    with open(file=name, mode="w") as file:
        for element in response:
            if isinstance(element, tuple) and len(element) == 2:
                file.write(str(element[0]) + separating_element + element[1] + "\n")
            else:
                logger.error("Each element in the response must be a tuple with exactly two items.")
                raise ValueError("Each element in the response must be a tuple with exactly two items.")
    file.close()
    logger.info(f"File {name} has been generated with the strings.")


def main():
    logging.basicConfig(level=logging.INFO)
    root.mainloop()


if __name__ == '__main__':
    main()
